<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	
	<title>reveal.js</title>
	
	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/blood.css">
	
	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">

	<link rel="stylesheet" href="css/local.css">
</head>
<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<span class="r-fit-text">
					<h1>Communiquer, collaborer, échanger à l'ère numérique</h1>
					<p>Introduction aux langages HTML et CSS</p>
				</span>
			</section>
			

			Document valide

De : M Martin <martin@parisnanterre.fr> A : Camille Claverie <cclaveri@parisnanterre.fr> ; Cécile Payeur<cpayeur@parisnanterre.fr > CC : secretariat-infocom@parisnanterre.fr Sujet : Emploi du temps date : 05/02/2021 pièce(s) jointe(s) : emploi-du-temps.xls
Bonjour, Vous trouverez ci-joint vos emplois du temps pour le second semestre. Cordialement, M. Martin Secrétariat Infocom Bat L - Université Paris Nanterre
Retour sur la séance précédente – correction exercice 2

Retour sur la séance précédente – correction exercice 2
e-mail expéditeur De : M Martin <martin@parisnanterre.fr> destinataires A : Camille Claverie <cclaveri@parisnanterre.fr> ; Cécile Payeur<cpayeur@parisnanterre.fr >  copie carbone CC : secretariat-infocom@parisnanterre.fr objet  Sujet : Emploi du temps date d’envoi date : 05/02/2021 documents attachés pièce(s) jointe(s) : emploi-du-temps.xls
message Bonjour, Vous trouverez ci-joint vos emplois du temps pour le second semestre. Cordialement, M. Martin Secrétariat Infocom Bat L - Université Paris Nanterre

Document valide

Document valide et schéma - notions
un document XML est un document bien formé !  
respecte les règles syntaxiques strictes de XML… cf. CM 1
un document XML – donc bien formé – peut être valide !
respecte une grammaire de document, qui s’exprime à travers une DTD ou un schéma

Une DTD (Document Type Definition) ou un schéma définit une classe de document XML, c’est-à-dire la liste des éléments et attributs autorisés, ainsi que le contexte dans lequel ils peuvent être appelés.
Il existe plusieurs syntaxes :
DTD (héritage de SGML)
XML Schema (W3C)
RelaxNG (norme ISO)
Document valide et schéma - notions




Document Type Definition

Document Type Definition
La DTD est un héritage de SGML, mais cette technologie est aujourd’hui obsolète : 
seule syntaxe disponible au lancement de XML en 1999
ne repose pas sur la syntaxe XML
ne supporte pas les espaces de nom (pas extensible)
pas de typage des données
expressivité limitée

Document Type Definition - exemple
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE person[
<!ELEMENT person (surname, forename*, birthDate, birthPlace) >
<!ELEMENT surname (#PCDATA) >
<!ELEMENT forename (#PCDATA) >
<!ELEMENT birthDate (#PCDATA) >
   <!ATTLIST birthDate when CDATA #REQUIRED>
<!ELEMENT birthPlace (#PCDATA) >
]>
<person>
   <surname>Turing</surname>
   <forename>Alan</forename>
   <forename>Mathison</forename>
   <birthDate when="1912-06-23">23 juin 1912</birthDate>
   <birthPlace>Londre</birthPlace>
</person>


Les Schémas

Les schémas – notions
rédigés en XML
introduction des types XML
support des espaces de noms
plus expressifs que les DTD
documentation
Définissent les contraintes que doit respecter une certaine classe de documents
Le but d'un schéma est de définir une classe de documents XML. Il permet de décrire les autorisations d'imbrication et l'ordre d'apparition des éléments et de leurs attributs, tout comme une DTD. Mais il permet aussi d'aller au-delà.
Another great strength about XML Schemas is that they are written in XML:
You don't have to learn a new language
You can use your XML editor to edit your Schema files
You can use your XML parser to parse your Schema files
You can manipulate your Schemas with the XML DOM
You can transform your Schemas with XSLT
One of the greatest strengths of XML Schemas is the support for data types:
It is easier to describe document content
It is easier to define restrictions on data
It is easier to validate the correctness of data
It is easier to convert data between different data types
espaces de nom = réutilisation de langage spécialisé et déjà existant. 
contrainte plus fine : Les indicateurs d'occurrences des éléments peuvent être tout nombre non négatif



XML schema
XML est donc un langage de description de contenus XML 

 
Structure de base
Un document XML schema est un fichier xml : 
prologue XML
élément racine <xs:schema/>
espace de nom préfixé “xs”
<?xml version="1.0" encoding="UTF-8"?> <!-- Prologue → <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">  <!-- Élément racine → </xs:schema>

Les éléments sont déclarés avec la balise <xs:element/>.
Deux attributs de base :
@name (obligatoire) pour indiquer le nom de la balise ;
@type pour spécifier le type de données.
Déclarations des éléments
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1" type="xs:string"/>
 <!-- élément <elem1/> pouvant contenir une simple chaîne de caractères-->
</xs:schema>


 
Déclarations des attributs
Les attributs sont déclarés avec la balise <xs:attribute/>.
Deux attributs de base :
@name (obligatoire) pour indiquer le nom de la balise ;
@type pour spécifier le type de données.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:attribute name="att" type="xs:date"/>
 <!-- déclaration d'un attribut @att dont la valeur est une date -->
</xs:schema>


les types simples
Les types
les types complexes
“Un schéma fournit un type à chaque élément et attribut qu’il déclare.”1
Deux types sont supportés pour les éléments par XML schema :
1Harold, Elliotte Rusty et Means, W. Scott. « XML en concentré : manuel de  référence »

un élément de type simple contient uniquement du texte
un élément de type simple ne peut pas posséder d’attributs ou contenir d’autres éléments
les attributs sont toujours de type simple
les principaux types simples prédéfinis sont : xs:string, xs:boolean, xs:date, xs:dateTime, xs:integer, xs:anyURI, etc.1
il est possible de dériver des types simples existants pour en créer d’autres (listes, unions, facettes). 
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1" type="xs:date"/>
 <!-- l’élément <elem1/> doit contenir une date (p. ex. 2021-11-18)-->
</xs:schema>

Les types simples
1 Liste des types https://www.w3.org/TR/xmlschema-0/#CreatDt

Une liste définit un type simple (préexistant ou dérivé) comme une liste de valeur d’un type de données.
N. B. : xs:NMTOKENS, xs:ENTITIES et xs:IDREFS sont déjà des type de liste. 
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <!-- elem1 peut contenir une suite de dates -->
 <xs:element name="elem1">
   <xs:simpleType>
     <xs:list itemType="xs:date"/>
   </xs:simpleType>
 </xs:element>
</xs:schema>

Les types simples – listes

L’élément xs:union est utilisé si on souhaite que le contenu d’un élément puisse être issu d’une collection de type de données
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <!-- elem1 peut contenir une date ou une date et une heure -->
 <!-- <elme1>2021-11-18</elme1> ou <elme1>2021-11-18T12:00:00</elme1>-->
 <xs:element name="elem1">
   <xs:simpleType>
     <xs:union memberTypes="xs:date xs:dateTime"/>
   </xs:simpleType>
 </xs:element>
</xs:schema>
Les types simples – unions

Les facettes, ou restrictions, permettent de spécifier des valeurs de manière plus précise. On utilise alors l’élément xs:restriction et l’attribut base, avec lequel on précise le type simple que l’on souhaite restreindre
Avec les facettes on peut par exemple contraindre la longueur d’une chaîne de caractère, spécifier une liste de valeurs possibles, ou encore imposer un pattern avec des expressions régulières.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <!-- elem1 peut contenir une chaîne de caractères dont la longueur est comprise entre 1 et 21 caractères -->
 <xs:element name="elem1">
   <xs:simpleType>
     <xs:restriction base="xs:string">
       <xs:minLength value="1"/>
       <xs:maxLength value="21"/>
     </xs:restriction>
   </xs:simpleType>
 </xs:element>
</xs:schema>

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<!-- elem1 doit contenir une chaîne de caractères dont la longueur est égale à 10 -->
<xs:element name="elem1">
  <xs:simpleType>
    <xs:restriction base="xs:string">
      <xs:length value="10"/>
    </xs:restriction>
  </xs:simpleType>
</xs:element>
</xs:schema>
Les types simples – facettes

Pour établir une liste de valeurs possibles, on utilisera l’élément xs:enumeration.
Dans l’exemple ci-contre, l’élément elem1 dispose d’un attribut att qui peut prendre comme valeur, exclusivement, valeur1, valeur2 ou valeur3.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
   <xs:complexType>
     <xs:attribute ref="att"/>
   </xs:complexType>
 </xs:element>
 <xs:attribute name="att">
   <xs:simpleType>
     <xs:restriction base="xs:string">
       <xs:enumeration value="valeur1"/>
       <xs:enumeration value="valeur2"/>
       <xs:enumeration value="valeur3"/>
     </xs:restriction>
   </xs:simpleType>
 </xs:attribute>
</xs:schema>

Les types simples – facettes 2

Pour établir un motif, ou pattern, à l’aide d’une expression régulière on utilisera l’élément xs:pattern.
Pour voir quelles facettes sont applicables à chaque type simple voir Simple Types & their Facets.

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
   <xs:simpleType>
     <xs:restriction base="xs:string">
       <xs:pattern value="\d\d\s\d\d\s\d\d\s\d\d\s\d\d"/>
       <xs:pattern value="(\w+)([-|.|_])?(\w+)?@(\w+)([-|_])?(\w+)?(\.)(\w+)"/>
     </xs:restriction>
   </xs:simpleType>
 </xs:element>
</xs:schema>

Les types simples – facettes 3

 
Les types complexes permettent d’introduire des contraintes d'occurrence, des séquences d’éléments, des choix d’éléments, des contenus complexes, etc.
Les types complexes sont définis avec l’élément xs:complexType.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<!-- un élément disposant d'un attribut est de type complexe -->
 <xs:element name="elem1">
   <xs:complexType>
     <xs:attribute name="att" type="xs:string"/>
   </xs:complexType>
 </xs:element>
</xs:schema>
Les types complexes

 
Les éléments apparaissent dans l’ordre définit par xs:sequence.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="elem1">
  <!-- elem1 doit contenir, dans l'ordre, les éléments elem2 et un elem3 -->
  <xs:complexType>
    <xs:sequence>
      <xs:element name="elem2" type="xs:string"/>
      <xs:element name="elem3" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
</xs:element>
</xs:schema>

Les types complexes – séquences

 
Un seul élément parmis plusieurs possibilité : xs:choice.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="elem1">
  <xs:complexType>
    <!--elem1 doit contenir, dans l'ordre, soit un élément elem2 ou elem3, puis obligatoirement un element elem4 -->
    <xs:sequence>
      <xs:choice>
        <xs:element name="elem2" type="xs:string"/>
        <xs:element name="elem3" type="xs:string"/>
      </xs:choice>
      <xs:element name="elem4" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
</xs:element>
</xs:schema>

Les types complexes – choix d’éléments

 
Avec xs:all tous les éléments enfants peuvent être appelés 0 fois (si on utilise l’attribut minOccurs=’0’) ou 1 fois, dans n’importe quel ordre.
À la différence des éléments xs:sequence et xs:choice qui peuvent être imbriqués, xs:all doit être un enfant directe de xs:complexType.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="elem1">
  <!-- elm1 peut contenir dans n'importe quel ordre elem2 et elem3 -->
  <xs:complexType>
    <xs:all>
      <xs:element name="elem2"/>
      <xs:element name="elem3"/>
    </xs:all>
  </xs:complexType>
</xs:element>
</xs:schema>

Les types complexes – xs:all

 
Il est possible d’établir des contraintes d’occurrence.
éléments, avec l’utilisation des attributs
minOccurs (nombre minimum)
maxOccurs (nombre maximum)
la valeur ‘unbounded’ indique un nombre indéterminé.
attributs
use (utilisation optionnelle ou requise)
‘optional’ | ‘required’
default (valeur par défaut)
fixed (valeur fixe)
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<!-- elem1 peut contenir :
 0 ou 1 elem2
 1 ou une infinité elem3
 optionnellement il peut avoir un attributs att, dont la valeur est fixe -->
<xs:element name="elem1">
 <xs:complexType>
   <xs:sequence>
     <xs:element name="elem2" type="xs:string" minOccurs="0" maxOccurs="1"/>
     <xs:element name="elem3" type="xs:string" maxOccurs="unbounded"/>
   </xs:sequence>
   <xs:attribute name="att" type="xs:date" use="optional" fixed="2021-01-01"/>
 </xs:complexType>
</xs:element>
</xs:schema>

Les types complexes – occurrences

 
L’attribut @mixed de valeur ‘true’ associé à l’élément xs:complexType indique que l’élément peut contenir des données textuelles et des éléments et/ou des attributs. 
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
   <xs:complexType mixed="true">
     <xs:all>
       <xs:element name="elem2"/>
       <xs:element name="elem3"/>
     </xs:all>
   </xs:complexType>
 </xs:element>
</xs:schema>

Les types complexes – contenu mixte

 
Dans l’exemple ci-contre, elem1 peut contenir du texte et autant de fois qu’on le souhaite les éléments elem2 et elem3, dans n’importe quel ordre.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
   <xs:complexType mixed="true">
     <xs:choice minOccurs="0" maxOccurs="unbounded">
       <xs:element name="elem2" type="xs:string"/>
       <xs:element name="elem3" type="xs:string"/>
     </xs:choice>
   </xs:complexType>
 </xs:element>
</xs:schema>
Les types complexes – contenu mixte 2

 
Dans l’exemple ci-contre, elem1 est un élément de type complexe qui peut contenir une chaîne de caractères pouvant contenir au maximum 10 caractères et un attribut att. Sans la définition d’un type simple simpleType et l’utilisation des éléments simpleContent et extension pour étendre ce type et autoriser l’utilisation d’un attribut att, il n’est pas possible de contrôler le contenu textuel d’un élément de type complexe.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
 <xs:complexType>
   <xs:simpleContent>
     <xs:extension base="simpleType">
       <xs:attribute ref="att"/>
     </xs:extension>
   </xs:simpleContent>
 </xs:complexType>
</xs:element>
<xs:simpleType name="simpleType">
 <xs:restriction base="xs:string">
   <xs:maxLength value="10"></xs:maxLength>
 </xs:restriction>
</xs:simpleType>
</xs:schema>
Les types (très) complexes

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
   <xs:complexType>
     <xs:sequence>
       <xs:element name="elem3" type="xs:string"/>
     </xs:sequence>
   </xs:complexType>
 </xs:element>
 <xs:element name="elem2">
   <xs:complexType>
     <xs:sequence>
       <xs:element name="elem3" type="xs:string"/>
     </xs:sequence>
   </xs:complexType>
 </xs:element>
</xs:schema>

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem3" type="xs:string"/>
 <xs:element name="elem1">
   <xs:complexType>
     <xs:sequence>
       <xs:element ref="elem3"/>
     </xs:sequence>
   </xs:complexType>
 </xs:element>
 <xs:element name="elem2">
   <xs:complexType>
     <xs:sequence>
       <xs:element ref="elem3"/>
     </xs:sequence>
   </xs:complexType>
 </xs:element>
</xs:schema>
 
Pour faciliter la maintenance du code et le rendre plus lisible, en évitant de multiplier les déclarations similaires (doublons) et les imbrications, il est possible de déclarer des éléments, des attributs, des types complexes et des types simples à un haut niveau.
Bonnes pratiques

 
Même chose avec le types simples ou complexes, afin de les définir une seule fois et les appeler lorsque c’est nécessaire.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="elem1">
   <xs:complexType>
     <xs:attribute name="att1" type="typePerso"/>
   </xs:complexType>
 </xs:element>
 <xs:element name="elem2" type="typePerso"/>
 <xs:simpleType name="typePerso">
   <xs:restriction base="xs:string">
     <xs:enumeration value="valeur1"/>
     <xs:enumeration value="valeur2"/>
   </xs:restriction>
 </xs:simpleType>
</xs:schema>

Bonnes pratiques

 
Les groupes d’attributs 
De la même manière, lorsque des attributs peuvent être utilisés avec plusieurs éléments, il est intéressant de déclarer des groupes d’attributs avec l’élément <xs:attributeGroup/>.
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="elem1">
  <xs:complexType>
    <xs:attributeGroup ref="attGroup"/>
  </xs:complexType>
</xs:element>
<xs:attributeGroup name="attGroup">
  <xs:attribute name="att1" type="xs:language"/>
  <xs:attribute name="att2" type="xs:string"/>
</xs:attributeGroup>
</xs:schema>


Validation
XML est donc un langage de description de contenus XML 

Déclarer un schéma dans un fichier XML
<?xml-model href="schema.xsd" type="application/xml" schematypens="http://www.w3.org/2001/XMLSchema"?>
On place une instruction de traitement <?xml-model ?> dans le prologue du document XML : 
l’attribut href : lien vers le schéma
l’attribut type : type de fichier
l’attribut schematypens : espace de nom du schéma

Valider un fichier XML
Avec un éditeur de texte qui prend (vraiment) en charge XML : 
Visual studio Code (https://code.visualstudio.com/) et les packages suivants :
XML : https://marketplace.visualstudio.com/items?itemName=redhat.vscode-xml
XML Tools : https://marketplace.visualstudio.com/items?itemName=DotJoshJohnson.xml
XSLT Transform : https://marketplace.visualstudio.com/items?itemName=WashirePie.vscode-xsl-transform
mais aussi Atom, Sublime Text, OxygenXML, WebStorm…
En ligne :
http://www.softwarebytes.org/xmlvalidation/
https://www.xmlvalidation.com/
En ligne de commande.



		</div>
	</div>
	
	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,
			
			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
		});
	</script>
</body>
</html>
