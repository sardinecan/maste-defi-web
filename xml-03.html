<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/blood.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css">

  <link rel="stylesheet" href="css/local.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <span class="r-fit-text">
          <h1>Document structuré et métadonnées</h1>
          <p class="alignCenter">Introduction au langage XML</p>
        </span>
      </section>


      <section>
        <section>
          <span class="r-fit-text">
            <h2>Retour sur la séance précédente – correction exercice 2</h2>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <p>
              De : M Martin &lt;martin@parisnanterre.fr&gt; A : Camille Claverie &lt;cclaveri@parisnanterre.fr&gt; ; Cécile Payeur &lt;cpayeur@parisnanterre.fr&gt;
            </p>
            <p>CC : secretariat-infocom@parisnanterre.fr Sujet : Emploi du temps date : 05/02/2021 </p>
            <p>pièce(s) jointe(s) : emploi-du-temps.xls</p>
            <p>Bonjour, </p>
            <p>Vous trouverez ci-joint vos emplois du temps pour le second semestre.</p>
            <p>Cordialement,</p>
            <p>M. Martin</p>
            <p>Secrétariat Infocom Bat L - Université Paris Nanterre</p>
          </span>
        </section>
      </section>

      <section>
        <section>
          <span class="r-fit-text">
            <h2>Document valide</h2>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h3>Document valide et schéma - notions</h3>
            <p>Un document XML est un document bien formé ! Il respecte les règles syntaxiques strictes de XML… cf. CM 1.</p>
            <p>Un document XML – donc bien formé – peut être valide ! Il respecte une grammaire de document, qui s’exprime à travers une DTD ou un schéma.</p>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <p>Une DTD (Document Type Definition) ou un schéma définit une classe de document XML, c’est-à-dire la liste des éléments et attributs autorisés, ainsi que le contexte dans lequel ils peuvent être appelés.</p>
            <p>Il existe plusieurs syntaxes :</p>
            <ul>
              <li>DTD (héritage de SGML)</li>
              <li>XML Schema (W3C)</li>
              <li>RelaxNG (norme ISO)</li>
            </ul>
          </span>
        </section>
      </section>
      
      
      
      <section>
        <section>
          <span class="r-fit-text">
            <h3>Document Type Definition</h3>
          </span>
        </section>
      
        <section>
          <span class="r-fit-text">
            <h4>Document Type Definition - notions</h4>
            <p>La DTD est un héritage de SGML, mais cette technologie est aujourd’hui obsolète :</p>
            <ul>
              <li>seule syntaxe disponible au lancement de XML en 1999</p>
              <li>ne repose pas sur la syntaxe XML</p>
              <li>ne supporte pas les espaces de nom (pas extensible)</p>
              <li>pas de typage des données</p>
              <li>expressivité limitée</p>
            </ul>
          </span>
        </section>
        
        <section>
          <span class="r-fit-text">
            <p>exemple</p>
            <pre>      
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                &lt;!DOCTYPE person[
                &lt;!ELEMENT person (surname, forename*, birthDate, birthPlace) &gt;
                &lt;!ELEMENT surname (#PCDATA) &gt;
                &lt;!ELEMENT forename (#PCDATA) &gt;
                &lt;!ELEMENT birthDate (#PCDATA) &gt;
                &lt;!ATTLIST birthDate when CDATA #REQUIRED &gt;
                &lt;!ELEMENT birthPlace (#PCDATA) &gt;
                ]&gt;
                <person>
                   <surname>Turing</surname>
                   <forename>Alan</forename>
                   <forename>Mathison</forename>
                   <birthDate when="1912-06-23">23 juin 1912</birthDate>
                   <birthPlace>Londre</birthPlace>
                </person>
              </code>
            </pre>
          </span>
        </section>
      </section>

      <section>
        <section>
          <span class="r-fit-text">
            <h3>Les Schémas</h3>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les schémas – notions</h4>
            <blockquote>
              <p>Another great strength about XML Schemas is that they are written in XML:</p>
              <ul>
                <li>You don't have to learn a new language</li>
                <li>You can use your XML editor to edit your Schema files</li>
                <li>You can use your XML parser to parse your Schema files</li>
                <li>You can manipulate your Schemas with the XML DOM</li>
                <li>You can transform your Schemas with XSLT</li>
                <li>One of the greatest strengths of XML Schemas is the support for data types:</li>
                <li>It is easier to describe document content</li>
                <li>It is easier to define restrictions on data</li>
                <li>It is easier to validate the correctness of data</li>
                <li>It is easier to convert data between different data types</li>
              </ul>
            </blockquote>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les schémas – notions</h4>
            <p>Définissent les contraintes que doit respecter une certaine classe de documents.</p>
            <ul>
              <li>rédigés en XML</li>
              <li>introduction des types XML</li>
              <li>support des espaces de noms</li>
              <li>plus expressifs que les DTD</li>
              <li>documentation</li>
            </ul>
            <p>Le but d'un schéma est de définir une classe de documents XML. Il permet de décrire les autorisations d'imbrication et l'ordre d'apparition des éléments et de leurs attributs, tout comme une DTD. Mais il permet aussi d'aller au-delà.</p>
            <p>Espaces de nom : réutilisation de langage spécialisé et déjà existant.</p>
            <p>Contrainte plus fine : les indicateurs d'occurrences des éléments peuvent être tout nombre non négatif.</p>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Structure de base</h4>
            <p>Un document XML schema est un fichier xml :</p>
            <ul>
              <li>prologue XML</li>
              <li>élément racine &lt;xs:schema/&gt;</li>
              <li>espace de nom préfixé “xs”</li>
            </ul>
            </span>
        </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <!-- Prologue-->
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                  <!-- Élément racine-->
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Déclarations des éléments</h4>
            <p>Les éléments sont déclarés avec la balise &lt;xs:element/&gt;.</p>
            <p>Deux attributs de base :</p>
            <ul>
              <li>@name (obligatoire) pour indiquer le nom de la balise ;</li>
              <li>@type pour spécifier le type de données.</li>
            </ul>
            </span>
            </section>
            <section>
              <span class="r-fit-text"></span>
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1" type="xs:string"></xs:element>
                 <!-- élément <elem1/> pouvant contenir une simple chaîne de caractères-->
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        
        <section>
          <span class="r-fit-text">
            <h4>Déclarations des attributs</h4>
            <p>Les attributs sont déclarés avec la balise &lt;xs:attribute/&gt;.</p>
            <p>Deux attributs de base :</p>
            <ul>
              <li>@name (obligatoire) pour indiquer le nom de la balise ;</li>
              <li>@type pour spécifier le type de données.</li>
            </ul>
            </span>
            </section>
            <section>
              <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:attribute name="att" type="xs:date"></xs:attribute>
                 <!-- déclaration d'un attribut @att dont la valeur est une date -->
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        
        <section>
          <span class="r-fit-text">
            <h3>Les types</h3>
            <blockquote>
              <p>Un schéma fournit un type à chaque élément et attribut qu’il déclare.</p>
              <cite>Harold, Elliotte Rusty et Means, W. Scott. « XML en concentré : manuel de référence »</cite>
            </blockquote>
            <p>Deux types sont supportés pour les éléments par XML schema :</p>
            <ul>
              <li>les types simples</li>
              <li>les types complexes</li>
            </ul>
            </span>
            </section>
            <section>
              <span class="r-fit-text">
                <h4>Les types simples</h4>
            <p>Un élément de type simple contient uniquement du texte.</p>
            <p>Un élément de type simple ne peut pas posséder d’attributs ou contenir d’autres éléments.</p>
            <p>les attributs sont toujours de type simple.</p>
            <p>les principaux types simples prédéfinis sont : xs:string, xs:boolean, xs:date, xs:dateTime, xs:integer, xs:anyURI, etc. Liste des types <a href="https://www.w3.org/TR/xmlschema-0/#CreatDt">https://www.w3.org/TR/xmlschema-0/#CreatDt</a></p>
            <p>Il est possible de dériver des types simples existants pour en créer d’autres (listes, unions, facettes).</p>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1" type="xs:date"></xs:element>
                 <!-- l’élément <elem1/> doit contenir une date (p. ex. 2021-11-18)-->
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types simple - listes</h4>
            <p>Une liste définit un type simple (préexistant ou dérivé) comme une liste de valeur d’un type de données.</p>
            <p>N. B. : xs:NMTOKENS, xs:ENTITIES et xs:IDREFS sont déjà des type de liste.</p>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                  <!-- elem1 peut contenir une suite de dates -->
                  <xs:element name="elem1">
                    <xs:simpleType>
                      <xs:list itemType="xs:date"></xs:list>
                   </xs:simpleType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types simples – unions</h4>
            <p>L’élément xs:union est utilisé si on souhaite que le contenu d’un élément puisse être issu d’une collection de type de données.</p>
          </span>
      </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <!-- elem1 peut contenir une date ou une date et une heure -->
                 <!-- <elme1>2021-11-18</elme1> ou <elme1>2021-11-18T12:00:00</elme1>-->
                 <xs:element name="elem1">
                   <xs:simpleType>
                     <xs:union memberTypes="xs:date xs:dateTime"></xs:union>
                   </xs:simpleType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types simples – facettes</h4>
            <p>
              Les facettes, ou restrictions, permettent de spécifier des valeurs de manière plus précise. On utilise alors
              l’élément xs:restriction et l’attribut base, avec lequel on précise le type simple que l’on souhaite
              restreindre.
            </p>
            <p>
              Avec les facettes on peut par exemple contraindre la longueur d’une chaîne de caractère, spécifier une liste
              de valeurs possibles, ou encore imposer un pattern avec des expressions régulières.
            </p>
          </span>
      </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <!-- elem1 peut contenir une chaîne de caractères dont la longueur est comprise entre 1 et 21 caractères -->
                 <xs:element name="elem1">
                   <xs:simpleType>
                     <xs:restriction base="xs:string">
                       <xs:minLength value="1"></xs:minLength>
                       <xs:maxLength value="21"></xs:maxLength>
                     </xs:restriction>
                   </xs:simpleType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <!-- elem1 doit contenir une chaîne de caractères dont la longueur est égale à 10 -->
                <xs:element name="elem1">
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:length value="10"></xs:length>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types simples – facettes 2</h4>
            <p>
              Pour établir une liste de valeurs possibles, on utilisera l’élément xs:enumeration.
              Dans l’exemple ci-contre, l’élément elem1 dispose d’un attribut att qui peut prendre comme valeur,
              exclusivement, valeur1, valeur2 ou valeur3.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                   <xs:complexType>
                     <xs:attribute ref="att"></xs:attribute>
                   </xs:complexType>
                 </xs:element>
                 <xs:attribute name="att">
                   <xs:simpleType>
                     <xs:restriction base="xs:string">
                       <xs:enumeration value="valeur1"></xs:enumeration>
                       <xs:enumeration value="valeur2"></xs:enumeration>
                       <xs:enumeration value="valeur3"></xs:enumeration>
                     </xs:restriction>
                   </xs:simpleType>
                 </xs:attribute>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types simples – facettes 3</h4>
            <p>
              Pour établir un motif, ou pattern, à l’aide d’une expression régulière on utilisera l’élément xs:pattern.
              Pour voir quelles facettes sont applicables à chaque type simple voir Simple Types & their Facets.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                   <xs:simpleType>
                     <xs:restriction base="xs:string">
                       <xs:pattern value="\d\d\s\d\d\s\d\d\s\d\d\s\d\d"></xs:pattern>
                       <xs:pattern value="(\w+)([-|.|_])?(\w+)?@(\w+)([-|_])?(\w+)?(\.)(\w+)"></xs:pattern>
                     </xs:restriction>
                   </xs:simpleType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes</h4>
            <p>Les types complexes permettent d’introduire des contraintes d'occurrence, des séquences d’éléments, des choix d’éléments, des contenus complexes, etc.</p>
            <p>Les types complexes sont définis avec l’élément xs:complexType.</p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <!-- un élément disposant d'un attribut est de type complexe -->
                 <xs:element name="elem1">
                   <xs:complexType>
                     <xs:attribute name="att" type="xs:string"></xs:attribute>
                   </xs:complexType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes – séquences</h4>
            <p>Les éléments apparaissent dans l’ordre définit par xs:sequence.</p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <xs:element name="elem1">
                  <!-- elem1 doit contenir, dans l'ordre, les éléments elem2 et un elem3 -->
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="elem2" type="xs:string"></xs:element>
                      <xs:element name="elem3" type="xs:string"></xs:element>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes – choix d’éléments</h4>
            <p>Un seul élément parmis plusieurs possibilité : xs:choice.</p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <xs:element name="elem1">
                  <xs:complexType>
                    <!--elem1 doit contenir, dans l'ordre, soit un élément elem2 ou elem3, puis obligatoirement un element elem4 -->
                    <xs:sequence>
                      <xs:choice>
                        <xs:element name="elem2" type="xs:string"></xs:element>
                        <xs:element name="elem3" type="xs:string"></xs:element>
                      </xs:choice>
                      <xs:element name="elem4" type="xs:string"></xs:element>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes – xs:all</h4>
            <p>
              Avec xs:all tous les éléments enfants peuvent être appelés 0 fois (si on utilise l’attribut minOccurs=’0’) ou
              1 fois, dans n’importe quel ordre.
            </p>
            <p>
              À la différence des éléments xs:sequence et xs:choice qui peuvent être imbriqués, xs:all doit être un enfant
              directe de xs:complexType.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <xs:element name="elem1">
                  <!-- elm1 peut contenir dans n'importe quel ordre elem2 et elem3 -->
                  <xs:complexType>
                    <xs:all>
                      <xs:element name="elem2"></xs:element>
                      <xs:element name="elem3"></xs:element>
                    </xs:all>
                  </xs:complexType>
                </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes – occurrences</h4>
            <p>Il est possible d’établir des contraintes d’occurrence.</p>
            <p>éléments, avec l’utilisation des attributs :</p>
            <ul>
              <li>minOccurs (nombre minimum)</li>
              <li>maxOccurs (nombre maximum)</li>
              <li>la valeur ‘unbounded’ indique un nombre indéterminé.</li>
            </ul>
            <p>attributs</p>
            <ul>
              <li>
                use (utilisation optionnelle ou requise)
                <ul>
                  <li>‘optional’ | ‘required’</li>
                </ul>
              </li>
              <li>default (valeur par défaut)</li>
              <li>fixed (valeur fixe)</li>
            </ul>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <!-- elem1 peut contenir :
                 0 ou 1 elem2
                 1 ou une infinité elem3
                 optionnellement il peut avoir un attributs att, dont la valeur est fixe -->
                <xs:element name="elem1">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="elem2" type="xs:string" minOccurs="0" maxOccurs="1"></xs:element>
                     <xs:element name="elem3" type="xs:string" maxOccurs="unbounded"></xs:element>
                   </xs:sequence>
                   <xs:attribute name="att" type="xs:date" use="optional" fixed="2021-01-01"></xs:attribute>
                 </xs:complexType>
                </xs:element>
                </xs:schema>  
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes – contenu mixte</h4>
            <p>
              L’attribut @mixed de valeur ‘true’ associé à l’élément xs:complexType indique que l’élément peut contenir des
              données textuelles et des éléments et/ou des attributs.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                   <xs:complexType mixed="true">
                     <xs:all>
                       <xs:element name="elem2"></xs:element>
                       <xs:element name="elem3"></xs:element>
                     </xs:all>
                   </xs:complexType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types complexes – contenu mixte 2</h4>
            <p>
              Dans l’exemple ci-contre, elem1 peut contenir du texte et autant de fois qu’on le souhaite les éléments elem2
              et elem3, dans n’importe quel ordre.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                   <xs:complexType mixed="true">
                     <xs:choice minOccurs="0" maxOccurs="unbounded">
                       <xs:element name="elem2" type="xs:string"></xs:element>
                       <xs:element name="elem3" type="xs:string"></xs:element>
                     </xs:choice>
                   </xs:complexType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Les types (très) complexes</h4>
            <p>
              Dans l’exemple ci-contre, elem1 est un élément de type complexe qui peut contenir une chaîne de caractères
              pouvant contenir au maximum 10 caractères et un attribut att. Sans la définition d’un type simple simpleType
              et l’utilisation des éléments simpleContent et extension pour étendre ce type et autoriser l’utilisation d’un
              attribut att, il n’est pas possible de contrôler le contenu textuel d’un élément de type complexe.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                 <xs:complexType>
                   <xs:simpleContent>
                     <xs:extension base="simpleType">
                       <xs:attribute ref="att"></xs:attribute>
                     </xs:extension>
                   </xs:simpleContent>
                 </xs:complexType>
                </xs:element>
                <xs:simpleType name="simpleType">
                 <xs:restriction base="xs:string">
                   <xs:maxLength value="10"></xs:maxLength>
                 </xs:restriction>
                </xs:simpleType>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                   <xs:complexType>
                     <xs:sequence>
                       <xs:element name="elem3" type="xs:string"></xs:element>
                     </xs:sequence>
                   </xs:complexType>
                 </xs:element>
                 <xs:element name="elem2">
                   <xs:complexType>
                     <xs:sequence>
                       <xs:element name="elem3" type="xs:string"></xs:element>
                     </xs:sequence>
                   </xs:complexType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem3" type="xs:string"></xs:element>
                 <xs:element name="elem1">
                   <xs:complexType>
                     <xs:sequence>
                       <xs:element ref="elem3"></xs:element>
                     </xs:sequence>
                   </xs:complexType>
                 </xs:element>
                 <xs:element name="elem2">
                   <xs:complexType>
                     <xs:sequence>
                       <xs:element ref="elem3"></xs:element>
                     </xs:sequence>
                   </xs:complexType>
                 </xs:element>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h3>Bonnes pratiques</h3>
            <p>
              Pour faciliter la maintenance du code et le rendre plus lisible, en évitant de multiplier les déclarations
              similaires (doublons) et les imbrications, il est possible de déclarer des éléments, des attributs, des types
              complexes et des types simples à un haut niveau.
            </p>
            <p>
              Cela permet de les définir une seule fois et les appeler lorsque c’est
              nécessaire.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                 <xs:element name="elem1">
                   <xs:complexType>
                     <xs:attribute name="att1" type="typePerso"></xs:attribute>
                   </xs:complexType>
                 </xs:element>
                 <xs:element name="elem2" type="typePerso"></xs:element>
                 <xs:simpleType name="typePerso">
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="valeur1"></xs:enumeration>
                     <xs:enumeration value="valeur2"></xs:enumeration>
                   </xs:restriction>
                 </xs:simpleType>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h3>Les groupes d’attributs</h3>
            <p>
              De la même manière, lorsque des attributs peuvent être utilisés avec plusieurs éléments, il est intéressant de déclarer des groupes d’attributs avec l’élément &lt;xs:attributeGroup /&gt;.
            </p>
          </span>
        </section>
          <section>
            <span class="r-fit-text">
            <pre>
              <code>
                <?xml version="1.0" encoding="UTF-8"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
                <xs:element name="elem1">
                  <xs:complexType>
                    <xs:attributeGroup ref="attGroup"/>
                  </xs:complexType>
                </xs:element>
                <xs:attributeGroup name="attGroup">
                  <xs:attribute name="att1" type="xs:language"/>
                  <xs:attribute name="att2" type="xs:string"/>
                </xs:attributeGroup>
                </xs:schema>
              </code>
            </pre>
          </span>
        </section>
      </section>
      <section>
        <section>
          <span class="r-fit-text">
            <h3>Validation</h3>
          </span>
        </section>
        <section>
          <span class="r-fit-text">
            <h4>Déclarer un schéma dans un fichier XML</h4>
            <pre>
              <code>
                &lt;?xml-model href="schema.xsd" type="application/xml" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;
              </code>
            </pre>
            <p>On place une instruction de traitement &lt;?xml-model ?&gt; dans le prologue du document XML :</p>
            <ul>
              <li>l’attribut href : lien vers le schéma</li>
              <li>l’attribut type : type de fichier</li>
              <li>l’attribut schematypens : espace de nom du schéma</li>
            </ul>
          </span>
        </section>
  
        <section>
          <span class="r-fit-text">
            <h4>Valider un fichier XML</h4>
            <p>Avec un éditeur de texte qui prend (vraiment) en charge XML :</p>
            <ul>
              <li>Visual studio Code (https://code.visualstudio.com/) et les packages suivants :
                <ul>
                  <li>XML : https://marketplace.visualstudio.com/items?itemName=redhat.vscode-xml</li>
                  <li>XML Tools : https://marketplace.visualstudio.com/items?itemName=DotJoshJohnson.xml</li>
                  <li>XSLT Transform : https://marketplace.visualstudio.com/items?itemName=WashirePie.vscode-xsl-transform</li>
                </ul>
              </li>
              <li>mais aussi Atom, Sublime Text, OxygenXML, WebStorm…</li>
            </ul>
            <p>En ligne :</p>
            <ul>
              <li>http://www.softwarebytes.org/xmlvalidation/</li>
              <li>https://www.xmlvalidation.com/</li>
            </ul>
            <p>En ligne de commande.</p>
          </span>
        </section>
</section>



    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>